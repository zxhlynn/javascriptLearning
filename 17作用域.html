<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.全局作用域
        // 直接编写在script标签中的js代码，都有全局作用域
        // 全局作用域在网页打开时创建，在网页关闭时销毁
        // 全局作用域中有一个window对象。
        // 它代表的是一个浏览器窗口。它由浏览器创建，我们可直接使用
        // 在全局作用域中，创建的变量都会成为window对象的属性
        // 全局作用域

        function overAll() {
            console.log("test");
        }

        var name = "window";

        window.overAll();

        console.log(window.name);


        /*
            变量声明提前，又叫变量提升
            - 使用var关键字声明的变量，会在所有代码之前被声明(但是不会赋值)，直到执行到赋值语句才会赋值
        
            如果声明变量时不加var,不会提前声明，会作为window对象的属性
        */

        aa = 100;

        console.log(window.aa);

        function test() {
            b = 1000;
        }

        test();

        console.log(window.b);


        var x = 100;

        function fun3() {
            x = 1000;
            var x;
            console.log(x); // 1000
            // 由于变量提升，则相当于
            /*
                var x;
                x = 1000;
                console.log(x);
            */
        }

        fun3();

        console.log(x); //100


        // 两种当方式声明函数，

        fun(); // 正常执行

        // fun2(); // 报错

        // 使用函数声明方式定义函数，它会在所有代码执行之前就被创建
        // 可参考java内存 方法区
        function fun() {
            console.log("我是一个函数");
        }

        var fun2 = function () {
            console.log("我是一个函数2");
        }


        // 2.函数作用域
        // 调用函数是创建函数作用域，函数执行完毕函数作用域销毁。
        // 每次调用函数就会创建一个新的函数作用域，他们之间是相互独立的
        // 函数作用域可以访问到，全局变量，但是全局变量作用域无法访问到函数作用域
        /*
        当在函数作用域操作一个变量时，会先在自身作用域中寻找，
        有就直接使用，没有则去上一级去寻找，一直找到全局作用域，
        全局作用域还没有则报RefereceError
        */
        // 在函数中要访问全局变量可以使用window.property
        // 定义形参相当于在函数作用域声明了变量




    </script>
</body>

</html>